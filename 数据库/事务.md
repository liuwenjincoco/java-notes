# 基础知识
## 概念
逻辑上的一组操作，要么都执行，要么都不执行
## ACID特性
* Atomicity(原子性)
    事物是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* Consistency(一致性)
    执行事务前后，数据保持一致
* Isolation(隔离性)
     并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事物之间数据库是独立的
* Durability(持久性)
    一个事物被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
    
## 并发事务带来的问题
* **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
* **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失
* **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读
* **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
* **不可重复读 VS 幻读**
    * 不可重复读的重点是**修改**
    * 幻读的重点在于**新增或者删除**
    
## 事务隔离级别
> 事务的隔离级别规定了一个事务中所做的修改，哪些在事务内和事物间是可见的，哪些是不可见的。较低的级别的隔离通常可以执行更高的并发，系统的开销也低。

* 未提交读(read-uncommitted)
    * 事务中的修改，即使没有提交，对其他事务也都是可见的。
* 提交读(read-committed)
    * 一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，
* 可重复读（repeatable-read）
    * 保证在同一个事务中多次读取同样记录的结果是一致的
    * **mysql默认事务隔离级别**
* 串行化（serializable)
    * 强制事务串行执行，避免了前面说的幻读的问题
    * 读取的每一行数据上都加锁，可能导致大量的超时和锁争用问题

**事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVCC（多版本并发控制），通过行的创建时间和行的过期时间来支持并发一致性读和回滚等特性**

**mysql使用repeatable-read作为默认的隔离级别，是由于历史mysql同步机制导致的，一般的商用数据库的默认隔离级别都是设置为read-commited级别**    

### 各事务级别下存在的问题
|事务隔离级别|脏读|不可重复读|幻读|
|:--:|:--:|:--:|:--:|:--:|
|未提交读（read-uncommitted）|是|是|是|
|提交读（read-committed)|否|是|是|
|可重复读（repeatable-read）|否|否|是|
|串行化（serializable)|否|否|否|

### 锁机制
* 锁粒度进行划分
    * 表级锁
        
        Mysql中锁定 **粒度最大**的一种锁，对当前操作的整张表加锁，**实现简单，资源消耗也比较少，加锁快，不会出现死锁**。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。
        
    * 行级锁
        
        Mysql中**锁粒度最小**的锁，只针对当前操作的行进行加锁。**行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。**InnoDB支持行级锁。
        
        * Record Lock:对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项。
        * Gap Lock:对索引项之间的”间隙“加锁，锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁)，不包含索引项本身。其他事务不能再锁范围内插入数据，这样就防止了别的事务新增幻影行。
        * Next-key Lock：锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读的问题。
        
    * 虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的：
        * 事务更新大表中的大部分数据直接使用表级锁效率更高。
        * 事务比较复杂，使用行级索很可能引起死锁导致回滚。

* 按照是否可写进行分类
    * 共享锁(share locks，简称S)
        * 又称之为读锁，其他用户可以并发读取数据，但任何事务不能获取数据上的排他锁，直到已释放所有共享锁。    
        * 事务T对数据对象A加了S锁，其余的事务都只能再对A加S锁，不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
    * 排他锁(Exclusive lock,简称X)
        * 若事务T对数据对象A加了X锁，只允许T读取和修改A，其他事务都不能再对A加任何类型的锁，直到T释放A上的锁。防止任何其他事务获取资源上的锁，知道事务的末尾将资源上的原始锁释放为止。在更新操作（Insert、update或delete）过程中始终应用排他锁。
* 意向锁

    
### 死锁和避免死锁

**InnoDB的行级锁是基于索引实现的，如果查询语句未命中任何索引，那么InnoDB会使用表级锁。**此外，InnoDB的行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用了相同的索引键仍然会出现锁冲突。

select for update 和 select lock in share mode使用锁的时候，**如果表没有定义任何索引，那么InnoDB会创建一个隐藏的聚簇索引并使用这个索引来加记录锁**

此外，不同于MyISAM总是**一次性获得所需的全部锁**，InnoDB的锁是**逐步获得的**，当两个事务都需要获得对方持有的锁，导致双方都在等待，这就产生了死锁。 发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务，我们可以采取以上方式避免死锁：

* 通过表级锁来减少死锁产生的概率；
* 多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；
* 同一个事务尽可能做到一次锁定所需要的所有资源。
    
