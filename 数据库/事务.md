# 基础知识
## 概念
逻辑上的一组操作，要么都执行，要么都不执行
## ACID特性
* Atomicity(原子性)
    事物是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
* Consistency(一致性)
    执行事务前后，数据保持一致
* Isolation(隔离性)
     并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事物之间数据库是独立的
* Durability(持久性)
    一个事物被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
    
## 并发事务带来的问题
* **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
* **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失
* **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读
* **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读
* **不可重复读 VS 幻读**
    * 不可重复读的重点是**修改**
    * 幻读的重点在于**新增或者删除**
    
## 事务隔离级别
> 事务的隔离级别规定了一个事务中所做的修改，哪些在事务内和事物间是可见的，哪些是不可见的。较低的级别的隔离通常可以执行更高的并发，系统的开销也低。

* 未提交读(read-uncommitted)
    * 事务中的修改，即使没有提交，对其他事务也都是可见的。
* 提交读(read-committed)
    * 一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，
* 可重复读（repeatable-read）
    * 保证在同一个事务中多次读取同样记录的结果是一致的
    * **mysql默认事务隔离级别**
* 串行化（serializable)
    * 强制事务串行执行，避免了前面说的幻读的问题
    * 读取的每一行数据上都加锁，可能导致大量的超时和锁争用问题
### 各事务级别下存在的问题
|事务隔离级别|脏读|不可重复读|幻读|
|:--:|:--:|:--:|:--:|:--:|
|未提交读（read-uncommitted）|是|是|是|
|提交读（read-committed)|否|是|是|
|可重复读（repeatable-read）|否|否|是|
|串行化（serializable)|否|否|否|
    
