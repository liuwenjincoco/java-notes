# mysql索引
## 索引使用的注意点
* 最左匹配原则：mysql会一直向右匹配索引直到遇到范围查询（>、<、between、like）就停止匹配，例如a = 1 and b = 2 and c > 3 and d = 4 ，如果建立了(a,b,c,d)的联合索引,d是用到索引的，如果建立了(a,b,d,c)的顺序，就都可以用到索引。a，b，d的查询语句中的顺序是可以随意该表的。
* = 和in可以乱序，比如比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的**查询优化器**会帮你优化成索引可以识别的形式。
* 尽量选择区分度搞的列作为索引，区分度的工时是count(distinct col)/count(*)
    * 表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
* 索引列不能参与计算，保持列”干净“
    * 比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
* 尽量的扩展索引，不要新建索引
    * 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
* 定义有外键的数据列一定要建立索引
* 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引
* 对于定义为text、image和bit的数据类型的列不要尽力索引
* 对于经常存取的列避免建立索引
* 尽量避免在where自子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描
* 尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
* 尽量避免在where子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引进而进行全表扫描。如：
    ```sql
        select id from t where num=10 or Name = 'fuzhu'
        可以替换为如下sql:
        select id from t where num = 10
        union all
        select id from t where Name = 'fuzhu'
    ```
* in 和 not in 也要慎用，否则会导致全表扫描
* 用exists代替in是一个好的选择，当然exists也不跑索引。
* like “%aaa%” 不会使用索引，而like “aaa%”可以使用索引
* 如果在 where 子句中使用参数，也会导致全表扫描。
* MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。