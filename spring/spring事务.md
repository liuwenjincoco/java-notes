# spring事务

https://blog.csdn.net/wwh578867817/article/details/51736723


**同一个类的一个方法调用一个有事务的方法，这个时候是不起作用的**：具体原因如下

```java
class A{
    @Transactinal  
    void b(){
    }
    
    void a(){
        b()
    }
}

class proxy$A{
    A obj = new A();

    void b(){
        startTransaction()；
        A.b();
    }
    
    void a(){
        obj.b();
    }
}


```

看上述的代码，即可理解为啥，事务没有生效了。

解决方案：
* 事务方法单独提取到一个service里面
* 在service调用，获取到代理对象，再调用代理方法，强行经过代理类，以激活事务切面。


## 传播机制

**事务的传播性一般在事务嵌套时候使用，比如在事务A里面调用了另外一个使用事务的方法，那么这俩个事务是各自作为独立的事务执行提交，还是内层的事务合并到外层的事务一块提交那，这就是事务传播性要确定的问题**

|propagation|msg|
|:--:|:--:|
|PROPAGATION_REQUIRED（XML文件中为REQUIRED)|表示当前方法必须在一个具有事务的上下文中运行，如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。（如果被调用端发生异常，那么调用端和被调用端事务都将回滚）|
|PROPAGATION_SUPPORTS(XML文件中为SUPPORTS）|表示当前方法不必需要具有一个事务上下文，但是如果有一个事务的话，它也可以在这个事务中运行|
PROPAGATION_MANDATORY(XML文件中为MANDATORY）|表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常|
|PROPAGATION_NESTED(XML文件中为NESTED)|表示如果当前方法正有一个事务在运行中，则该方法应该运行在一个嵌套事务中，被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在，并且外层事务抛出异常回滚，那么内层事务必须回滚，反之，内层事务并不影响外层事务。如果封装事务不存在，则同PROPAGATION_REQUIRED的一样|
|PROPAGATION_NEVER（XML文件中为NEVER)|表示当方法务不应该在一个事务中运行，如果存在一个事务，则抛出异常|
|PROPAGATION_REQUIRES_NEW(XML文件中为REQUIRES_NEW）|表示当前方法必须运行在它自己的事务中。一个新的事务将启动，而且如果有一个现有的事务在运行的话，则这个方法将在运行期被挂起，直到新的事务提交或者回滚才恢复执行。|
|PROPAGATION_NOT_SUPPORTED（XML文件中为NOT_SUPPORTED）|表示该方法不应该在一个事务中运行。如果有一个事务正在运行，他将在运行期被挂起，直到这个事务提交或者回滚才恢复执行|

### REQUIRED,REQUIRES_NEW,NESTED异同
* NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。
* REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。
* NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。**此处需要注意，内部方法需要自己处理异常，若内部方法将异常抛出，且外部方法没对该方法做异常捕获，可能导致外围事务感知到异常，导致整个事务的回滚。**
* NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。